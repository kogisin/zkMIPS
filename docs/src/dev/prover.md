# Prover

The zkm_sdk crate provides all the necessary tools for proof generation. Key features include the `ProverClient`, enabling you to:
- Initialize proving/verifying keys via `setup()`.
- Execute your program via `execute()`.
- Generate proofs with `prove()`.
- Verify proofs through `verify()`.

When generating Groth16 or PLONK proofs, the `ProverClient` automatically downloads the pre-generated proving key (pk) from a trusted setup by calling `try_install_circuit_artifacts()`.

## Example: [Fibonacci](https://github.com/ProjectZKM/Ziren/blob/main/examples/fibonacci/host/src/main.rs)

The following code is an example of using zkm_sdk in host.

```rust
use zkm_sdk::{include_elf, utils, ProverClient, ZKMProofWithPublicValues, ZKMStdin};

/// The ELF we want to execute inside the zkVM.
const ELF: &[u8] = include_elf!("fibonacci");

fn main() {
    // Create an input stream and write '1000' to it.
    let n = 1000u32;

    // The input stream that the guest will read from using `zkm_zkvm::io::read`. Note that the
    // types of the elements in the input stream must match the types being read in the program.
    let mut stdin = ZKMStdin::new();
    stdin.write(&n);

    // Create a `ProverClient` instance.
    let client = ProverClient::new();

    // Execute the guest using the `ProverClient.execute` method, without generating a proof.
    let (_, report) = client.execute(ELF, stdin.clone()).run().unwrap();
    println!("executed program with {} cycles", report.total_instruction_count());

    // Generate the proof for the given program and input.
    let (pk, vk) = client.setup(ELF);
    let mut proof = client.prove(&pk, stdin).run().unwrap();

    // Read and verify the output.
    //
    // Note that this output is read from values committed to in the program using
    // `zkm_zkvm::io::commit`.
    let n = proof.public_values.read::<u32>();
    let a = proof.public_values.read::<u32>();
    let b = proof.public_values.read::<u32>();

    println!("n: {}", n);
    println!("a: {}", a);
    println!("b: {}", b);

    // Verify proof and public values
    client.verify(&proof, &vk).expect("verification failed");
}
```

## Proof Types

Ziren provides customizable proof generation options:

```rust
/// A proof generated with Ziren of a particular proof mode.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(ZKMProofKind))]
pub enum ZKMProof {
    /// A proof generated by the core proof mode.
    ///
    /// The proof size scales linearly with the number of cycles.
    #[strum_discriminants(default)]
    Core(Vec<ShardProof<CoreSC>>),
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    Compressed(Box<ZKMReduceProof<InnerSC>>),
    /// A proof generated by the Plonk proof mode.
    Plonk(PlonkBn254Proof),
    /// A proof generated by the Groth16 proof mode.
    Groth16(Groth16Bn254Proof),
}
```

### [Core Proof (Default)](https://github.com/ProjectZKM/Ziren/blob/main/examples/fibonacci/host/src/main.rs)

The default prover mode generates a sequence of STARK proofs whose cumulative proof size scales linearly with the execution trace length.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).run().unwrap();
```

### [Compressed Proof](https://github.com/ProjectZKM/Ziren/blob/main/examples/fibonacci/host/bin/compressed.rs)

The compressed proving mode generates constant-sized STARK proofs, but not suitable for on-chain verification.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).compressed().run().unwrap();
```

### [Groth16 Proof (Recommended)](https://github.com/ProjectZKM/Ziren/blob/main/examples/fibonacci/host/bin/groth16_bn254.rs)

The Groth16 proving mode ​generates succinct SNARK proofs with a compact size of approximately 260 bytes, ​and features on-chain verification.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).groth16().run().unwrap();
```

### [PLONK Proof](https://github.com/ProjectZKM/Ziren/blob/main/examples/fibonacci/host/bin/plonk_bn254.rs)

The PLONK proving mode generates succinct SNARK proofs with a compact size of approximately 868 bytes, while maintaining on-chain verifiability. In contrast to Groth16, PLONK removes the dependency on trusted setup ceremonies.

```rust
let client = ProverClient::new();
client.prove(&pk, stdin).plonk().run().unwrap();
```

## Hardware Acceleration

### GPU Acceleration

Ziren leverages CUDA-based GPU acceleration to achieve significantly lower latency and superior cost-performance relative to a CPU-based prover, even when the CPU employs AVX vector instruction extensions.

#### Software Requirements

To get started with the CUDA prover, please confirm that your system meets the following requirements:
- [CUDA 12](https://developer.nvidia.com/cuda-12-8-0-download-archive?target_os=Linux&target_arch=x86_64&Distribution=Ubuntu&target_version=22.04&target_type=deb_local)
- [CUDA Container Toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html)

#### Hardware Requirements

- ​​Processor:​​ 4-core CPU or higher
- ​​System Memory:​​ 16GB RAM or higher
- ​​Graphics Card:​​ 24GB or higher VRAM

> To use Ziren with GPU acceleration, ensure your NVIDIA GPU has a compute capability of at least 8.6. You can verify this by checking the [official NVIDIA documentation](https://developer.nvidia.com/cuda-gpus).

#### Usage

To initialize the CUDA prover, choose one of the following methods to build your client:

- ​Option A (Environment Variable):​​ Use `ProverClient::new()` and ensure the `ZKM_PROVER` environment variable is set to `cuda`, eg. `export ZKM_PROVER=cuda`.
- ​​Option B (Direct Method):​​ Use `ProverClient::cuda()`.

With the client built, you can then proceed to generate proofs using its standard methods.

### CPU Acceleration

Ziren provides hardware acceleration support for [`AVX256/AVX512`](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) on x86 CPUs due to support in [`Plonky3`](https://github.com/Plonky3/Plonky3).

You can check your CPU's AVX compatibility by running:

```shell
grep avx /proc/cpuinfo
```

Check if you can see `avx2` or `avx512` in the results.

To activate **AVX256** optimization, add these flags to your RUSTFLAGS environment variable:

```shell
RUSTFLAGS="-C target-cpu=native" cargo run --release
```

To activate **AVX512** optimization, add these flags to your RUSTFLAGS environment variable:

```shell
RUSTFLAGS="-C target-cpu=native -C target-feature=+avx512f" cargo run --release
```

## Network Prover
We support a network prover via the ZKM Proof Network, accessible through our RESTful API.The network prover currently supports only the **Groth16** proving mode.
>The proving process consists of several stages: queuing, splitting, proving, and finalizing.
Each stage may take a different amount of time.

### Requirements

- **CA certificate:** `ca.pem`, `ca.key`. These keys are stored [here](https://github.com/ProjectZKM/Ziren/tree/main/crates/sdk/tool)
- [Register](https://www.zkm.io/apply) your address to gain access.
- **SDK dependency**: add `zkm_sdk` from the Ziren SDK to your `Cargo.toml`:
```toml
zkm-sdk = { git = "https://github.com/ProjectZKM/Ziren" }
```
### Environment Variable Setup
Before running your application, export the following environment variables to enable the network prover:
```bash
export ZKM_PRIVATE_KEY=<your_private_key>       # Private key corresponding to your registered public key
export SSL_CERT_PATH=<path_to_ssl_certificate>  # Path to the SSL client certificate (e.g., ssl.pem)
export SSL_KEY_PATH=<path_to_ssl_key>           # Path to the SSL client private key (e.g., ssl.key)
```
You can generate the SSL certificate and key by running the [`certgen.sh`](https://github.com/ProjectZKM/Ziren/blob/main/crates/sdk/tool/certgen.sh) script.

**Optional**: You can also set the following environment variables to customize the network prover behavior:

```bash
export SHARD_SIZE=<shard_size>              # Size of each shard in bytes. 
export MAX_PROVER_NUM=<max_prover_num>      # Maximum number of provers to use in parallel.
export SINGLE_NODE=<true|false>             # Whether to use a single node for proving (default: false).
```


To host your own network prover, export the following variables to configure your endpoint:
```bash
export ENDPOINT=<proof_network_endpoint>        # Proof network endpoint (default: https://152.32.186.45:20002)
export CA_CERT_PATH=<path_to_ca_certificate>    # Path to CA certificate (default: ca.pem)
export DOMAIN_NAME=<domain_name>                # Domain name (default: "stage")
```

### Example

The following example shows how to use the network prover on the host:

```rust
use std::env;
use zkm_sdk::{include_elf, ProverClient, ZKMStdin};
const FIBONACCI_ELF: &[u8] = include_elf!("fibonacci");
fn main() {
    utils::setup_logger();

    let mut stdin = ZKMStdin::new();
    stdin.write(&10usize);
    let elf = test_artifacts::FIBONACCI_ELF;
    
    // create network client
    let client = ProverClient::network();
    let (pk, vk) = client.setup(elf);
    let proof = client.prove(&pk, stdin).run().unwrap();
    client.verify(&proof, &vk).unwrap();
}
```
