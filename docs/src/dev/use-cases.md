# Use Cases: GOAT Network

GOAT Network is a Bitcoin L2, the first L2 to be implemented on ZKM’s Entangled Network. As a full-stack Bitcoin-based zkRollup, GOAT leverages Ziren (ZKM’s in-house zkVM) to enable real-time proving, trustless bridging, and Bitcoin-native settlement.

**Proving Block Execution**

Ziren is used to generate ZK proofs for individual blocks processed by GOAT’s sequencers. Each proof demonstrates that a block was executed correctly and that its resulting state transitions are valid. To amortize costs, proofs are generated over a specific period rather than for each transaction individually.

The proof contains the hash of the associated block, root hash of the sequencer set and new state root. These values are bundled and submitted to the Bitcoin L1. The block hash and the root hash serve as public inputs to the ZK circuit and are required to match the corresponding values that have already been posted on Bitcoin L1.

**Real-Time Proving & Peg-Out Proofs**

Ziren enables the generation of proofs in real time for every block on GOAT, which powers the BitVM2 bridge used for withdrawals during the peg-out process. This capability eliminates the delays that can otherwise occur during withdrawals, allowing funds to be released in sync with block production rather than requiring days (or even weeks) of waiting.

During the peg-out process, operators act as provers to generate ZK proofs for peg-out transactions. Challengers can contest invalid proofs within an optimistic challenge window.

The proof generation pipeline for peg-outs consists of several stages:

- Root Prover: Computes core execution trace.
- Aggregation Prover: Compresses multiple core proofs.
- SNARK Prover: Generates Groth16 proofs (allowing for an EVM-compatible format) for Bitcoin verification.

This architecture enables low-latency withdrawals and the rapid inclusion of new blocks. View proofs being generated in real-time for GOAT, including details for each proof in the pipeline here: https://bitvm2.testnet3.goat.network/proof.

**Proof Verification via BitVM Paradigm**

Once generated, proof commitments are submitted to a BitVM2-anchored covenant on Bitcoin L1 and is verified via BitVM2’s fraud-proof challenge mechanism. Verification involves confirming that the public inputs of the ZK proof correspond to a valid transaction on Bitcoin L1 and that this transaction is finalized within a sufficiently long proof-of-work chain.

All ZK proofs are tied to the committed state; any attempt to manipulate the state would produce a different public input, which would cause verification to fail. Both the L2 state and its execution are fully auditable by any participant.

**Transaction Lifecycle**

The following is an overview of the transaction lifecycle on GOAT and Ziren’s role in it:

1. A user first submits a transaction to the L2.
2. The sequencer batches and executes transactions into an L2 block, which is then processed by Ziren.
3. Ziren generates a ZK proof that attests to the correctness of the block’s execution and its state transitions.
4. The ZK proof generated by Ziren, together with the state commitment, are submitted to a BitVM2-anchored covenant on the Bitcoin L1. 

**Entangled Rollup Use Case**

ZKM’s primary use case is Entangled Network, using validity proofs to verify cross-chain messaging between L2s without implementing the architecture of a bridge. In this way, security is natively inherited by the underlying L1 e.g., Bitcoin in the case of GOAT, as opposed to a third-party bridge which has its own security tradeoffs such as custodial risk, use of wrapped assets, additional trust assumptions, and multisig control.

By treating the L2s as bridges, all L2s part of the Entangled Rollup Network can share state, liquidity and execution. Ziren is used to generate valid proofs of state transitions, proving the execution of blocks in the L2s to be verified on their underlying L2s.

Ziren underpins GOAT’s cross-chain interoperability through the Entangled Rollup Network:

- Rollup proofs double as bridge receipts—a single validity proof can verify execution on one L2 and unlock assets on another.
- Enables native asset transfers across incompatible chains (e.g., Bitcoin ↔ Ethereum L2s).
- Validity proofs ensure L1-final settlement across chains, preserving each chain’s native security.

Read more about how Entangled Network enables native assets and unified liquidity between (even incompatible) chains [here](https://www.zkm.io/whitepaper/entangled-rollups-wp).

.