extern crate alloc;

use core::borrow::Borrow;
use core::convert::AsRef;
use itertools::Itertools;

use p3_commit::{Pcs, TwoAdicMultiplicativeCoset};
use p3_field::FieldAlgebra;
use p3_field::PrimeField32;
use p3_field::TwoAdicField;
use p3_koala_bear::KoalaBear;
use serde::{Deserialize, Serialize};
use strum_macros::{EnumDiscriminants, EnumTryAs};
use zkm_core_executor::ZKMReduceProof;
use zkm_primitives::{io::ZKMPublicValues, poseidon2_hash};
use zkm_stark::ShardProof;
use zkm_stark::{
    air::PublicValues, koala_bear_poseidon2::KoalaBearPoseidon2, StarkGenericConfig,
    StarkVerifyingKey, Word, DIGEST_SIZE,
};

use error::StarkError;
use verify::verify_stark_compressed_proof;

pub mod error;
mod verify;

/// A proof generated with Ziren of a particular proof mode.
/// Redefined due to SDK's non-no_std limitation, and is used only for deserialization.
#[derive(Debug, Clone, Serialize, Deserialize, EnumDiscriminants, EnumTryAs)]
#[strum_discriminants(derive(Default, Hash, PartialOrd, Ord))]
#[strum_discriminants(name(ZKMProofKind))]
pub enum ZKMProof {
    /// A proof generated by the core proof mode.
    ///
    /// The proof size scales linearly with the number of cycles.
    #[strum_discriminants(default)]
    Core(Vec<ShardProof<CoreSC>>),
    /// A proof generated by the compress proof mode.
    ///
    /// The proof size is constant, regardless of the number of cycles.
    Compressed(Box<ZKMReduceProof<InnerSC>>),
    /// A proof generated by the Plonk proof mode.
    Plonk(PlonkBn254Proof),
    /// A proof generated by the Groth16 proof mode.
    Groth16(Groth16Bn254Proof),
    /// Compressed-proof-to-Groth16 conversion.
    CompressToGroth16,
}

/// A zero-knowledge proof generated by the PLONK protocol with a Base64 encoded gnark PLONK proof.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct PlonkBn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub plonk_vkey_hash: [u8; 32],
}

/// A zero-knowledge proof generated by the Groth16 protocol with a Base64 encoded gnark Groth16
/// proof.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Groth16Bn254Proof {
    pub public_inputs: [String; 2],
    pub encoded_proof: String,
    pub raw_proof: String,
    pub groth16_vkey_hash: [u8; 32],
}

/// The configuration for the core prover.
pub type CoreSC = KoalaBearPoseidon2;

/// The configuration for the inner prover.
pub type InnerSC = KoalaBearPoseidon2;

/// The information necessary to verify a proof for a given MIPS program.
#[derive(Clone, Serialize, Deserialize)]
pub struct ZKMVerifyingKey {
    pub vk: StarkVerifyingKey<CoreSC>,
}

pub trait HashableKey {
    /// Hash the key into a digest of KoalaBear elements.
    fn hash_koalabear(&self) -> [KoalaBear; DIGEST_SIZE];
}

/// A verifier for stark zero-knowledge proofs.
#[derive(Debug)]
pub struct StarkVerifier;

impl StarkVerifier {
    /// Verifies a Ziren compressed proof, as generated by the Ziren SDK.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `public_inputs` - The Ziren public inputs, which are committed by the guest as a bincode-serialized byte array.
    /// * `zkm_vk` - The Ziren vkey bytes.
    ///   This is generated in the following manner:
    ///
    /// ```ignore
    /// use zkm_sdk::ProverClient;
    /// let client = ProverClient::new();
    /// let (pk, vk) = client.setup(ELF);
    /// ```
    ///
    /// # Returns
    ///
    /// A success [`Result`] if verification succeeds, or a [`StarkError`] if verification fails.
    ///
    /// Compared to `verify_proof()`, it performs a consistency check between
    /// user-supplied public values and those committed in the proof.
    pub fn verify(proof: &[u8], zkm_public_inputs: &[u8], zkm_vk: &[u8]) -> Result<(), StarkError> {
        let proof: ZKMProof = bincode::deserialize(proof).expect("failed to deserialize the proof");
        let ZKMProof::Compressed(proof) = proof else { panic!("expected a compressed proof") };
        let public_inputs = ZKMPublicValues::from(zkm_public_inputs);
        let vk: ZKMVerifyingKey =
            bincode::deserialize(zkm_vk).expect("failed to deserialize the vk");

        let proof_public_values: &PublicValues<Word<_>, _> =
            proof.proof.public_values.as_slice().borrow();

        // Get the committed value digest bytes.
        let committed_value_digest_bytes = proof_public_values
            .committed_value_digest
            .iter()
            .flat_map(|w| w.0.iter().map(|x| x.as_canonical_u32() as u8))
            .collect_vec();

        // Make sure the committed value digest matches the public values hash.
        for (a, b) in committed_value_digest_bytes.iter().zip_eq(public_inputs.hash()) {
            if *a != b {
                return Err(StarkError::InvalidPublicValues);
            }
        }

        verify_stark_compressed_proof(&vk, &proof).map_err(StarkError::Recursion)
    }

    /// Verifies a Ziren compressed proof, as generated by the Ziren SDK.
    ///
    /// # Arguments
    ///
    /// * `proof` - The proof bytes.
    /// * `zkm_vk` - The Ziren vkey bytes.
    ///
    /// Compared to `verify()`, it does not perform a consistency check between
    /// user-supplied public values and those committed in the proof.
    pub fn verify_proof(proof: &[u8], zkm_vk: &[u8]) -> Result<(), StarkError> {
        let proof: ZKMProof = bincode::deserialize(proof).expect("failed to deserialize the proof");
        let ZKMProof::Compressed(proof) = proof else { panic!("expected a compressed proof") };
        let vk: ZKMVerifyingKey =
            bincode::deserialize(zkm_vk).expect("failed to deserialize the vk");

        verify_stark_compressed_proof(&vk, &proof).map_err(StarkError::Recursion)
    }
}

impl<SC: StarkGenericConfig<Val = KoalaBear, Domain = TwoAdicMultiplicativeCoset<KoalaBear>>>
    HashableKey for StarkVerifyingKey<SC>
where
    <SC::Pcs as Pcs<SC::Challenge, SC::Challenger>>::Commitment: AsRef<[KoalaBear; DIGEST_SIZE]>,
{
    fn hash_koalabear(&self) -> [KoalaBear; DIGEST_SIZE] {
        let prep_domains = self.chip_information.iter().map(|(_, domain, _)| domain);
        let num_inputs = DIGEST_SIZE + 1 + 14 + (4 * prep_domains.len());
        let mut inputs = Vec::with_capacity(num_inputs);
        inputs.extend(self.commit.as_ref());
        inputs.push(self.pc_start);
        inputs.extend(self.initial_global_cumulative_sum.0.x.0);
        inputs.extend(self.initial_global_cumulative_sum.0.y.0);
        for domain in prep_domains {
            inputs.push(KoalaBear::from_canonical_usize(domain.log_n));
            let size = 1 << domain.log_n;
            inputs.push(KoalaBear::from_canonical_usize(size));
            let g = KoalaBear::two_adic_generator(domain.log_n);
            inputs.push(domain.shift);
            inputs.push(g);
        }

        poseidon2_hash(inputs)
    }
}
